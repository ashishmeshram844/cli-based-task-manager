"""
Daily task management console based
- create alias of command and run from anywhere
    - add - create new task
    - update - update a provided id task
    - delete - delete a provided id task
    - list - list all tasks
"""

import sys
import sqlite3
from prettytable import PrettyTable

conn = sqlite3.connect('/home/ashish/Desktop/personal_projects/my-work/daily_tasks.db')


class WorkConsole():
    def __init__(self):
        self.cursor = self.get_cursor()

    def create_cursor(self,conn = conn):
        """
        Crates a cursor object for connection
        """
        cursor = conn.cursor()
        return cursor

    def create_task_table(self,cursor):
        """
        Create a Table where all tasks will be stored
        - created only when not available in db
        """
        table_name = "Tasks"
        columns = "(id INTEGER PRIMARY KEY AUTOINCREMENT, datetime DATETIME DEFAULT CURRENT_TIMESTAMP, task_detail TEXT)"
        create_table_query = f"CREATE TABLE IF NOT EXISTS {table_name} {columns}"
        cursor.execute(create_table_query)
        conn.commit()

    def get_cursor(self):
        """
        gives the cursor object 
        """
        cursor = self.create_cursor()
        self.create_task_table(cursor)
        return cursor
        
    def add_task(self,task):
        """
        Responsible to add new task in table
        """
        try:    
            result = self.cursor.execute("INSERT INTO Tasks (task_detail) VALUES (?)", (task,))
            conn.commit()
            print("\033[32m Task Addedd Successfully  \033[0m")
        except Exception as e:
            print("\033[31m Failed to add Task !  \033[0m")

    def display_tasks(self,tasks_data):
        """
        Helper function which display all tasks list in tabular format
        """
        table = PrettyTable()
        table.field_names = ["ID", "DATE", "TASK DETAIL"]
        for row in tasks_data:
            table.add_row([row[0], row[1], row[2]])
        table.max_width = 80
        table.align = 'l'
        print(table)
        
    def fetch_all_tasks(self):
        """
        get all tasks list
        """
        result = self.cursor.execute("SELECT * FROM Tasks ORDER BY id DESC").fetchall()
        return result

    def list_tasks(self):
        """
        get all task list and display on screen
        """
        try:
            result = self.fetch_all_tasks()
            self.display_tasks(result)
        except Exception as e:
            print("\033[31m Failed to Load Tasks List !  \033[0m")

    def check_task_is_avail(self,task_id):
        """
        check inputed id value task is available in table or not
        """
        row = self.cursor.execute("SELECT * FROM Tasks WHERE id = ?", (task_id,)).fetchone()
        return not row is None

    def delete_task(self,task_id):
        """
        Responsible to delete task which id is provided by user
        """
        try:
            if self.check_task_is_avail(task_id):
                self.cursor.execute("DELETE FROM Tasks WHERE id = ?", (task_id,))
                conn.commit()
                print("\033[32m Task Deleted Successfully  \033[0m")
            else:
                print("\033[31m Task is not Available | Failed to delete  !  \033[0m")
        except Exception as e:
            print("\033[31m Failed to Delete Tasks  !  \033[0m")

    def update_task(self,task_id):
        """
        Update specific task which user provide id
        """
        if self.check_task_is_avail(task_id):
            row = self.cursor.execute("SELECT * FROM Tasks WHERE id = ?", (task_id,)).fetchone()
            print("Task Detail : ",row[2])
            updated_task = str(input("Enter Updated Task Detail : "))
            update_query = """
                UPDATE Tasks
                SET task_detail = ?
                WHERE id = ?
            """
            task_detail = updated_task
            self.cursor.execute(update_query, (task_detail, task_id))
            conn.commit()
            print("\033[32m Task Updated Successfully  \033[0m")
        else:
            print("\033[31m Task is not Available | Failed to Update  !  \033[0m")

    def take_user_operation(self):
        """
        This function takes input from user which want to perform operation
        """
        operation = str(input("work@ashish : "))
        return operation

    def add_operation(self,splitted_operations):
        """
        Handle add new task operation
        """
        if len(splitted_operations) == 1:
            task = str(input("Enter a Task : "))
            self.add_task(task)
        else:
            print("\033[31m No extra parameter required in add !  \033[0m")

    def update_operation(self,splitted_operations):
        """
        Handle Update specific task operation task
        """
        try:
            if len(splitted_operations) == 2:
                self.update_task(splitted_operations[1])
            else:
                task_id = int(input("Enter task ID : "))
                self.update_task(task_id)
        except Exception as e:
            print("\033[31m Failed to update Task !  \033[0m")

    def delete_operation(self,splitted_operations):
        """
        Handle Delet Task operation
        """
        try:
            if len(splitted_operations) == 2:
                self.delete_task(splitted_operations[1])
            else:
                task_id = int(input("Enter Task ID : "))
                self.delete_task(task_id)
        except Exception as e:
            print("\033[31m Please Provide proper Id of task !  \033[0m")

    def operation_handle(self,splitted_operations):
        """
        This function handle all operations perform related to Tasks table
        """
        if splitted_operations[0] in ['add','delete','update','list']:
            match splitted_operations[0]:
                case 'add':
                    self.add_operation(splitted_operations)
                case 'update':
                    self.update_operation(splitted_operations)
                case 'delete':
                    self.delete_operation(splitted_operations)
                case 'list':
                    self.list_tasks()
                case _:
                    print("\033[31m Wrong Opeeration !  \033[0m")
        else:
            print("\033[33m This Operation is not allowd !  \033[0m")

    def main(self):
        """
        main runnner function which responsible to run programme till input exit
        """
        app_status = True 
        while app_status:
            operation = self.take_user_operation()
            if operation == "exit":
                print("Application Closed")
                break
            splitted_operations = operation.split(" ")
            if len(splitted_operations) <= 2:
                self.operation_handle(splitted_operations)
            else:
                print("\033[33m Cant use more than two arguments at a time !  \033[0m")

if __name__ == '__main__':
    """
    Entry point of programme
    """
    obj = WorkConsole()
    obj.main()
   
    
